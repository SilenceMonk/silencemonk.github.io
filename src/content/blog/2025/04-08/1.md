---
title: '单源最短路径 (SSSP) 问题'
description: "这节课主要讲的是**单源最短路径 (Single-Source Shortest Paths - SSSP)** 问题及其求解算法。"
date: 2025-04-08
tags: ['算法复习']
authors: ['saaaadcat']
---

1. **问题定义**:
    * 给定一个**加权的、有向的**图 G 和一个**源顶点 s**。
    * 目标是计算从源点 s 到图中**所有**其他可达顶点的**最短路径**的权重（以及路径本身）。
    * 最终结果通常表示为一个**最短路径树 (shortest-path tree)**。

2. **核心操作：松弛 (Relaxation)**:
    * 所有算法都依赖于**松弛**操作 `Relax(u, v, w)`。
    * 该操作检查是否可以通过顶点 `u` 找到一条到达顶点 `v` 的更短路径。即，如果 `d[v] > d[u] + w(u, v)`，则更新 `d[v]` 为 `d[u] + w(u, v)`，并将 `v` 的前驱 `π[v]` 设为 `u`。
    * `d[v]` 存储从源点 `s` 到顶点 `v` 的当前最短路径权重的**估计值**，`π[v]` 存储 `v` 在当前计算出的路径上的**前驱节点**。
    * 一个重要的性质是**三角不等式**: `δ(s, v) ≤ δ(s, u) + w(u, v)`，其中 `δ` 表示真实的最短路径权重。算法维护的不变量是 `d[v] ≥ δ(s, v)`。

3. **重要前提和属性**:
    * **最优子结构**: 最短路径的子路径也是最短路径。这是动态规划和贪心算法能应用的基础。
    * **前驱子图 (Predecessor Subgraph)**: 由 `π[v]` 定义的边构成的子图 `G_π`。在没有从 `s` 可达的负权环时，`G_π` 最终会形成一个以 `s` 为根的最短路径树。

4. **主要算法**:

    * **Bellman-Ford 算法**:
        * **适用性**: 可以处理**带有负权边**的图。
        * **功能**: 能够**检测**从源点可达的**负权环**。如果图中存在这样的环，算法会报告；否则，计算出最短路径。
        * **方法**: 对图中的所有边进行 `|V|-1` 次松弛操作。之后再检查一次所有边，如果仍有边可以被松弛，则说明存在负权环。
        * **复杂度**: O(VE)，其中 V 是顶点数，E 是边数。
        * 本质上是一种**动态规划**方法。

    * **有向无环图 (DAG) 上的最短路径算法**:
        * **适用性**: 专门用于**有向无环图 (DAG)**。
        * **功能**: 可以在 DAG 上高效地计算最短路径，即使存在负权边（因为 DAG 没有环，所以不可能有负权环）。
        * **方法**: 先对图进行**拓扑排序**，然后按照拓扑顺序依次处理每个顶点，并对其所有出边进行松弛操作。
        * **复杂度**: O(V + E)，非常高效。

    * **Dijkstra 算法**:
        * **适用性**: **前提是图中没有负权边**。
        * **功能**: 计算非负权图中的单源最短路径。
        * **方法**: 采用**贪心策略**。维护一个集合 `S`，包含已确定最短路径的顶点。使用一个**优先队列 `Q`** 存储 `V-S` 中的顶点，按 `d[v]` 值（当前路径估计）排序。每次从 `Q` 中取出 `d` 值最小的顶点 `u`，加入 `S`，并对 `u` 的所有出边进行松弛。
        * **复杂度**: 取决于优先队列的实现：
            * 线性数组: O(V^2)
            * 二叉堆: O((V + E) log V) 或 O(E log V)
            * 斐波那契堆: O(V log V + E)（理论上最优）

**总结**: 这节课介绍了求解单源最短路径问题的基本概念（松弛、最短路径树）和三种主要算法：Bellman-Ford（通用，能处理负权边和检测负权环）、DAG 算法（高效，用于无环图）和 Dijkstra（高效，用于非负权图）。选择哪种算法取决于图的特性（是否有负权边、是否为 DAG）。
