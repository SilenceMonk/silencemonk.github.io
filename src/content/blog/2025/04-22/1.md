---
title: 'Splay Trees能怎么考'
description: ''
date: 2025-04-22
tags: ['算法']
authors: ['saaaadcat']
---

好的，我们来详细讲解一下 Splay Trees (伸展树)，并分析可能的考察方式。

**什么是 Splay Tree？**

Splay Tree 是一种**自调整 (self-adjusting)** 的二叉搜索树 (BST)。与 AVL 树、红黑树、B 树等依赖**显式规则 (explicit rules)** 来强制维持平衡不同，Splay Tree **没有严格的平衡规则 (no such rules)**。

它的核心思想是：每当对树中的某个节点 `x` 进行访问（查找、插入、删除关联的操作）后，就通过一系列称为 **伸展 (splaying)** 的旋转操作，将节点 `x` **移动到树的根部**。

**Splay Tree 的动机和特性:**

1. **自调整特性:** 频繁访问的节点会倾向于靠近根部，使得后续对这些节点的访问变得更快。这体现了良好的**局部性 (locality)** 特性。
2. **摊销效率 (Amortized Efficiency):** 虽然单次操作的最坏情况可能是 O(n)（比如树退化成链状），但 Splay Tree 保证了任何 M 次连续操作的总时间复杂度为 O(M log n)。这意味着**平均到每次操作**，其**摊销时间复杂度 (amortized time)** 为 **O(log n)**。它通过偶尔付出较高的代价（将深层节点旋转到根）来“支付”未来可能的快速访问。
3. **相对简单:** 相比 AVL 树或红黑树，Splay Tree 的旋转规则和实现通常被认为更简单一些，因为它不需要存储额外的平衡因子或颜色信息。

**核心操作：Splaying (伸展)**

伸展操作是将指定节点 `x` 移动到根部的一系列旋转步骤。它包含三种基本的子操作（或它们的对称形式）：

1. **Zig (单旋转):**
    * **条件:** 当 `x` 的父节点 `y` 就是根节点时。
    * **操作:** 对 `x` 和 `y` 进行一次标准的 BST 旋转（如果 `x` 是 `y` 的左孩子就右旋，反之左旋）。
    * **效果:** `x` 成为新的根。`x` 的深度减少 1。
    * *(对应 Slide 12)*

2. **Zig-Zig (双旋转 - 同向):**
    * **条件:** `x` 有父节点 `y`，`y` 有父节点 `z` (即 `x` 有祖父节点)，并且 `x` 和 `y` 同为左孩子，或者同为右孩子。
    * **操作:** 先旋转 `y` 和 `z`，再旋转 `x` 和 `y`。
    * **效果:** `x` 上升两层。`x` 的深度减少 2。
    * *(对应 Slide 10)*

3. **Zig-Zag (双旋转 - 异向):**
    * **条件:** `x` 有父节点 `y`，`y` 有父节点 `z`，并且 `x` 是 `y` 的右孩子而 `y` 是 `z` 的左孩子，或者反之 (`x` 是左孩子，`y` 是右孩子)。
    * **操作:** 先旋转 `x` 和 `y`，再旋转 `x` 和 `z` (注意，是两次围绕 `x` 的旋转)。
    * **效果:** `x` 上升两层。`x` 的深度减少 2。
    * *(对应 Slide 11)*

**伸展过程:** 只要 `x` 还不是根节点，就持续应用 Zig、Zig-Zig 或 Zig-Zag 操作，直到 `x` 成为根节点为止。

**何时进行 Splay 操作？ (When to Splay)**

Splay 操作通常在标准的 BST 操作之后进行：

* **Search (查找):**
  * **查找成功:** 对找到的节点 `x` 进行 Splay 操作。
  * **查找失败:** 对查找路径上**最后访问的那个内部节点** (last-visited internal node) 进行 Splay 操作。*(Slide 21)*
* **Insert (插入):** 对**新插入的节点**进行 Splay 操作。*(Slide 21)*
* **Delete (删除):**
  * 标准的 BST 删除可能涉及到替换节点（用前驱或后继）。
  * Splay 操作作用于**被删除节点的父节点** (parent of removed node)。注意，这个父节点可能是在节点被物理移除 *之前* 的父节点，特别是当被删除节点有两个孩子时，实际移除的是它的后继（或前驱），这时要 Splay 的是被删除节点（原始那个）的父节点。*(Slide 21)*

**摊销分析简介 (Amortized Analysis)**

* **核心思想 (Accounting Method):** 为每个操作分配一个“摊销成本”。如果摊销成本 > 实际成本，多余部分作为“信用 (credit)”存起来（比如存在树的节点上）。如果摊销成本 < 实际成本，用之前存的信用支付差额。目标是证明任何操作序列的总摊销成本是总实际成本的上界，且信用永不为负。
* **Splay Tree 的势函数/信用:** 通常使用基于节点大小 `n(v)` 或其对数（秩 `r(v) = log(n(v))`）的势函数或信用系统。*(Slides 22-27)*
* **关键结果:** 通过证明每次 Zig/Zig-Zig/Zig-Zag 操作的摊销成本是 O(log n)，可以得出整个 Splay 操作的摊销成本是 O(log n)。*(Slides 29-37)*
  * 一次 Splay 操作的总摊销成本被证明是 O(r(t) - r(x))，其中 t 是根，x 是被 splay 的节点，这通常是 O(log n)。*(Slide 37)*
* **BST 操作成本:** 标准 BST 查找、插入节点（不含 Splay）的实际成本与访问深度相关，删除操作也类似。这些成本可以通过 Splay 操作存储的信用或摊销成本来“支付”。插入操作本身会增加树的总秩，需要额外分析，但最终结论是插入的摊销成本也是 O(log n)。*(Slides 38-40)*
* **最终结论:** 搜索、插入、删除操作的摊销时间复杂度都是 O(log n)。*(Slide 41)*

**如何考察 Splay Tree？**

基于课程内容和这种数据结构的特点，考察方式可能包括：

1. **模拟 Splay 操作 (最可能考的操作模拟题):**
    * 给定一棵初始的 Splay Tree（或 BST）。
    * 要求执行一次 Search(k), Insert(k), 或 Delete(k) 操作。
    * 关键在于**正确地执行随后的 Splay 操作**。你需要判断每一步应该用 Zig, Zig-Zig, 还是 Zig-Zag，并准确地画出每次旋转后的树形态。
    * 可能会要求画出中间步骤，或者只画出最终 Splay 完成后的树。
    * *(类似 Slides 13-20 的完整 Splay 过程)*

2. **概念理解:**
    * Splay Tree 与其他平衡树（AVL, RB, B-Tree）的区别（自调整 vs 严格规则）。
    * 什么是摊销分析？Splay Tree 的时间复杂度为什么是摊销 O(log n) 而不是最坏情况 O(log n)？
    * Splay 操作的目标是什么？（移动节点到根）
    * Zig, Zig-Zig, Zig-Zag 操作分别适用于什么情况？
    * Splay Tree 的优点和缺点（优点：对访问局部性友好，均摊效率高，实现相对简单；缺点：单次操作最坏 O(n)，树形态变化剧烈可能不适合某些并发场景）。
    * 在 Search/Insert/Delete 后，应该对哪个节点进行 Splay？

3. **摊销分析（可能难度较高）：**
    * 可能会问摊销分析的基本原理（会计法/势能法）。
    * 可能会问 Splay Tree 中定义的“秩 (rank)” 或 “大小 (size)” 是什么。
    * 可能会问信用不变式 (Credit Invariant) 是什么，以及它如何保证总摊销成本是总实际成本的上界。
    * 直接证明摊销界限可能过于复杂，但可能会问一些证明中的关键引理或结论（比如 Proposition 1 或 2 的结论）。

4. **对比分析:**
    * 比较 Splay Tree 和其他数据结构（如 Skip List, B-Tree, AVL Tree）在不同场景下的性能优劣和特点。*(Midterm 1 Q1.4, Q1.5 就是这种类型)*

**复习重点:**

* **熟练掌握 Zig, Zig-Zig, Zig-Zag 三种旋转操作的执行过程和条件。** 这是考模拟题的基础。多画几遍 Slides 10, 11, 12 的例子。
* **理解何时以及对哪个节点进行 Splay。**
* **记住 O(log n) 摊销时间复杂度这个结论，并理解“摊销”的含义。**
* 了解 Splay Tree 的基本优缺点和适用场景。

如果课程深入讲解了摊销分析的数学证明，那也需要相应复习，但对于大多数算法课程，手动模拟 Splay 操作是最高频的考点。
